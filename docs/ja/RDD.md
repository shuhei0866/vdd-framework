# RDD（Release-Driven Development）

## 概要

RDD は、リリース可能な動作変更を作業単位にし、実装過程よりも「ユーザーに届く価値」を中心に開発を進める方法論である。コミットや PR は手段であり、リリースこそが作業の単位となる。

## 基本原則

1. **リリースが作業単位**: コミットや PR ではなく、リリース可能な動作変更が作業の単位
2. **コードではなく動作を見る**: レビュー対象はコードそのものではなく動作の変化
3. **TDD は RDD の一部**: 自動テストはリリース品質検証の機械化可能な部分を担う
4. **スコープとリスクを明示**: リリースごとにスコープとリスクを明記する

## 役割分担

| 役割 | 担当者 | 責務 |
|------|--------|------|
| 要件定義 | 人間 | 何を達成したいか |
| 設計対話 | 人間 + AI | 実装方針の議論と合意 |
| 実装・テスト | AI | TDD での自律的実装 |
| 自己評価・レビュー | AI | 品質の自律的検証 |
| QA | 人間 | 価値と品質の最終確認 |

## 標準フェーズ

### Phase 0: 要件定義（人間）

- 「何をしたいのか」の本質的な目的を述べる
- ユーザーストーリー、達成したいゴール、制約条件の明示
- この段階では実装方針は含まない

### Phase 1: 設計対話（人間 + AI）

- 要件に基づき、実装方針を AI と議論する
- 対話中にリリース分割が発生したら、リリースツリーを出力して構造を可視化する
- 成果物: リリース仕様書

### Phase 2: 自律実装（AI）

- worktree でリリースブランチ `release/<name>` を作成
- リリース仕様書をコミット
- TDD サイクルで実装
- リリース仕様書の範囲外の変更をしない

### Phase 3: 自己評価 + 独立レビュー（AI）

- プロジェクトのチェックコマンドで型チェック・lint・テストを通す
- 自己評価を実行
- 独立コンテキストでのコードレビューを実行（多角的レビュー推奨）
- 指摘があれば修正し、再度通す
- PR を作成

### Phase 4: マージ + QA（AI + 人間）

- PR のマージ先は統合ブランチ（`develop`）
- 独立レビュアーの承認を確認後にマージ
- 本番ブランチ（`main`）への昇格は人間がトリガー

## 必須成果物

### リリース仕様書

各リリースには仕様書を作成する。以下を必須で含む:

- リリースで期待される動作
- スコープ外の明示
- リスク要因の明示
- テスト戦略

**配置例**: `.claude/release-specs/{release-name}.md`

## リリース粒度ルール

- 1リリース = 1つの独立したデプロイ可能な変更
- ロールバック可能であること
- 他のリリースとの不要な依存を持たないこと
- DB マイグレーション等の競合リスクがある変更を含む場合は明示すること

## リリース分類（2層モデル）

### レイヤー1: RDD リリース

全てのリリースブランチのマージが RDD リリース。タグなしも含む。

### レイヤー2: バージョンタグ付きリリース（選択的）

| 分類 | 対象 | バージョンタグ | GitHub Release |
|------|------|---------------|----------------|
| developer-only | リファクタ、CI、ドキュメント、内部改善 | なし | なし |
| user-facing (bugfix) | ユーザーに見えるバグ修正 | patch | 作成 |
| user-facing (feature) | 新機能追加 | minor | 作成 |
| user-facing (breaking) | 破壊的変更 / メジャーマイルストーン | major | 作成 |

### 判断基準

1. **ユーザーに見える動作変更を含むか？** → No なら developer-only（タグなし）
2. **バグ修正か新機能か？** → bugfix なら patch、feature なら minor
3. **複数リリースのバッチ** → 意味単位・変更の大きさでまとめて1つのセマンティックバージョンにしてよい

## リリースツリー

設計対話（Phase 1）の中で、要件が複数リリースに分割される場合がある。その構造を対話中に可視化するため、テキストベースのリリースツリーを使用する。

### 目的

- 対話の途中で「今、リリースがいくつに分かれていて、どういう順序関係か」を常に見える化する
- リリースの分割・統合・順序変更を対話の中で合意できる
- リリース仕様書を書く前に、リリース構造の合意が取れている状態を作る

### フォーマット

```
[R1] release/<name>
│    <概要（1行）>
│
├──▶ [R2] release/<name>
│         <概要>
│
└──▶ [R3] release/<name>
          <概要>
```

### ルール

- **番号は時間軸**: R1 → R2 → R3 の順にリリースする
- **分岐はサフィックス**: R3 から分岐 → R3a, R3b（並列実行可能）
- **`├──▶` は依存関係**: 矢印の先が後続リリース

### 直列の例

```
[R1] release/data-schema
│    DB: 新テーブル追加
│
└──▶ [R2] release/data-ui
          UI: データ表示・操作
          │
          └──▶ [R3] release/data-integration
                    他機能との統合
```

### 並列の例

```
[R1] release/data-schema
│    DB: 新テーブル追加
│
├──▶ [R2] release/data-ui
│         UI: データ表示・操作
│
└──▶ [R3] release/data-api
          API: CRUD エンドポイント
```

## AI への指示（自律実装時）

- リリース仕様書を常に参照し、スコープ外の変更をしない
- 仕様に曖昧さがあれば人間に確認する。それ以外は確認不要
- 実装中に発見した洞察・気づきは記録する（PR description の `Insights` セクション等）
- テストファースト（TDD）を厳守する

## 情報の三層構造

| 層 | 目的 | 保存場所 |
|----|------|---------|
| 完全性 | 全対話ログを原文保存 | ローカル（gitignore） |
| 理解可能性 | 設計経緯の要約 | PR description（永続） |
| 開発洞察 | 実装中の発見・気づき | PR description の Insights セクション |

### 開発洞察の記録ルール

実装中に以下のような発見があった場合、記録すること:

- 既存コードの潜在的な問題やリスク
- 想定と異なる動作・仕様の発見
- 将来の実装に影響する技術的制約
- パフォーマンスやセキュリティに関する気づき
- 設計判断の理由（なぜその方法を選んだか）

## VDD との関係

RDD は実行エンジン、VDD は上流入力レイヤー。VDD で定義された方向性と意思決定を受け取り、RDD でリリース単位に落とし込む。詳細は [VDD.md](./VDD.md) を参照。
