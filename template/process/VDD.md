# VDD（Vision-Driven Development）

## 目的

日々の意思決定からビジョンを継続的に更新し、そのビジョンを入力として自律開発を回す。

## 基本方針

1. 自然言語中心で運用する
2. 解釈ブレを減らすために「置き場所」を固定する
3. 過度なスキーマ化は避ける（必要最小限のみ）

## 主要アーティファクト

- Vision 正本（`VISION.md`）
  - 現在の方向性
  - 重視する価値
  - 今はやらないこと
  - 品質バー
- 意思決定台帳（`DECISIONS.md`）
  - 1行1意思決定
  - 理由・影響・優先度・根拠
- 日次主観スコア（`DAILY_SCORE.md`）
  - 当日の主観スコア（1-5）
  - 「良いものを早くリリースできた実感」のコメント

## 運用ループ

1. **前回の学びを確認する**: フィードバック会の冒頭で前回の決定と学びを確認する
2. 意思決定の場（フィードバック会 / レビュー会）
3. 決定を台帳へ反映
4. Vision 正本を更新
5. 日次主観スコアを記録
6. リリース仕様へ反映
7. RDD で実装・レビュー・QA
8. **VDD 運用の振り返り**: VDD プロセス自体に関する学びがあれば `process/VDD-learnings.md` に記録する

## 運用ルール

### 会議運用

- 定期的な固定運用（フィードバック会 / PRレビュー会）
- 会議内の時間配分は固定しない（都度最適化）

### 役割分担

- AI: 会議アジェンダと意思決定候補を提案する
- 人間: 候補ごとに承認判定を行う（最終決定者）

### 承認フォーマット

- `approve`（承認）
- `reject`（却下）
- `conditional`（条件付き承認）
- `conditional` は条件が満たされるまで実装着手不可
- `conditional` の条件は自由文で記述する
- 条件達成は運用で判断する

### アーティファクト更新ルール

- `VISION.md`:
  - 毎日更新は必須ではない
  - 方向性・価値・品質バーに変更があった場合は更新する
- `DECISIONS.md`:
  - 会議で扱った意思決定を記録する（根拠と文脈を必須）
  - `decision_id` は日次リセット連番を使用する（例: `D-20260207-01`）
  - 「なぜそう判断したか（context）」を重視する
- `DAILY_SCORE.md`:
  - 日次で主観スコアを記録する（1-5）
  - 記録先は `VISION.md` / `DECISIONS.md` とは分離する（肥大化防止）

### 意思決定の矛盾処理

- 新しい意思決定が過去の決定と矛盾する場合は、`supersedes` で置換元 `decision_id` を明示する
- 置換された決定は `status: superseded` とする

### ステータス

- `active`: 有効な決定
- `dropped`: 撤回された決定
- `superseded`: 新しい決定で置き換えられた決定（置き換え元の decision_id を記録）

### RELEASE_SPEC 連携

- リリース仕様書の作成タイミングは厳密な閾値で固定しない
- AI が提案し、人間が承認したタイミングで作成する
- `release/*` マージ前に、以下8項目を必須チェックとして通す:
  - Vision整合
  - Decision整合
  - conditional解消
  - 主要導線非破壊
  - リスク明示
  - ロールバック可能
  - レビュー通過
  - スコープ逸脱なし

## ディベートパートナー（意思決定の質を上げる仕組み）

リリース仕様書の作成後、外部の AI とディベート的な対話を行い、ビジョン整合を検証する。

### なぜ外部化するか

ディベートパートナーは意図的にプロジェクトの外部に置く。コンテキストを完全には共有していない相手への説明は、以下の効果を生む：

- **暗黙の前提を炙り出す**: 省略できない説明が、自分が当然視していたことに気づかせる
- **本質を平易に言い換える**: 専門用語や内部構造が通じないため、「何のためにやるのか」を自分の言葉で再構成する
- **意思決定のラバーダッキング**: 技術レビューは「コードの正しさ」を検証する。ディベートは「判断の正しさ」を検証する

### 原則

- **ポジションを取る**: 賛成/反対の立場を明確にして議論する
- **反論に耐えたアイデアが残る**: 表面的な同意ではなく、攻撃されても成立する判断を目指す
- **結論だけ記録**: DECISIONS.md には結論と「ディベートした」事実を記録
- **パートナーは「壁打ち相手」であり「審判」ではない**: 最終判断は常に人間

### 問いの設計

#### 設計原則

1. **Yes/No を避ける**: 立場を取らざるを得ない問いにする
2. **「正解」より「選択」**: 正解がある問いより、トレードオフを問う
3. **反論を前提にする**: 相手が攻撃してくることを織り込んだ問い方をする

#### 問いの例

| 問い | 炙り出すもの |
|------|-------------|
| 「これを使うのは誰で、今どうしてるの？」 | ユーザー像の解像度 |
| 「それ、作らなくても解決する方法ない？」 | 実装バイアス |
| 「3ヶ月後もこれ使ってると思う？」 | 一時的な熱量 vs 持続的な価値 |
| 「この機能が成功したら、何が変わる？」 | ゴールの明確さ |
| 「VISION.md の『今はやらないこと』に抵触しない？」 | ビジョン整合 |

## 意思決定権限マトリクス

| 判断の種類 | 決定者 | 基準 | 人間確認 |
|-----------|--------|------|---------|
| `release/* -> develop` マージ | 実装エージェント | レビュアー approve 後 | 不要 |
| `develop -> main` 昇格 | 人間 | フィードバック会で QA 通過 | 必須 |
| 設計方針の採否 | 人間 | ディベート後に approve/reject | 必須 |
| 実装中の技術判断 | AI | RELEASE_SPEC スコープ内 | 不要 |
| RELEASE_SPEC の作成 | 人間 | AI が提案、人間が承認 | 必須 |
| リファクタリング判断 | AI | スコープ内かつテスト通過 | 不要 |
| Vision/Decision の更新 | 人間 | 会議で合意 | 必須 |

## ガードレール

- Vision と矛盾する実装方針は理由を明記する
- 根拠が追跡できない決定は優先度を上げない
- 複数解釈が成立する場合は人間確認を優先する
- 本番不具合リスクが高い場合は自律実装を停止して確認する
- ユーザー影響が極めて大きい変更は確認する
- ロールバック困難な変更は確認する
- Vision 整合に疑義がある場合は確認する

## 成功判定

- 日次で主観スコアを `DAILY_SCORE.md` に記録する（1-5）
- 評価軸は「良いものを早くリリースできた実感」

## ブランチ戦略（簡略化 GitFlow）

### 3層構造

```
main (production)     <- 人間が昇格トリガー
  |
develop (integration) <- レビュアー approve 後に実装エージェントがマージ
  |
release/* (作業)      <- worktree で TDD 実装
```

### 運用ルール

1. **develop は永続ブランチ**: 削除しない。main と同格の長命ブランチ
2. **マージ方向**:
   - `release/* -> develop`: レビュー approve 後に実装エージェントが実行
   - `develop -> main`: 人間がトリガー
   - `main -> develop`: main に直接入った変更（hotfix 等）を同期
3. **main への直接マージ禁止**: `release/*` から main への直接マージはフックでブロック（hotfix 除く）
4. **昇格後の同期**: `develop -> main` 昇格後、develop を main にリベースして同期する

### QA の3層モデル

| Layer | 実行者 | 内容 |
|-------|--------|------|
| Layer 1: 自動検証 | AI | チェックコマンド, E2E テスト, コードレビュー |
| Layer 2: 視覚チェック | AI + 人間 | スクリーンショット評価、preview 操作 |
| Layer 3: 探索的 QA | 人間 | preview URL で直接操作、違和感を拾う |

- Layer 1 + 2 を AI が自律的にイテレーション
- Layer 3 は人間がフィードバック会で実施
- develop -> main 昇格は Layer 3 通過後

## RDD との関係

VDD は「何を目指すか」を更新する層、RDD は「どう届けるか」を実行する層。
両者を分離することで、戦略の更新と実装の安定性を両立する。
