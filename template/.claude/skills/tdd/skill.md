---
name: tdd
description: テスト駆動開発（TDD）をサブエージェントで効率的に実行。テスト設計→実装→実行→機能実装のサイクルを並列処理で高速化。新機能の実装、バグ修正、リファクタリング、関数やコンポーネントの追加・変更など、コードを書く作業全般でトリガーされる。ユーザーが「実装して」「作って」「修正して」「追加して」と言った場合や、feature/fix/refactor に関わるタスクで自動的に使用すること。
---

# TDD スキル

## Overview

サブエージェントを活用したテスト駆動開発ワークフロー。Red-Green-Refactor サイクルを効率的かつ網羅的に実行します。

**Announce at start:** "TDDスキルを使ってテスト駆動開発を開始します。"

## 使用方法

```
/tdd <対象ファイルまたは機能の説明>
/tdd src/lib/feature.ts
/tdd "ユーザー認証のバリデーション機能"
```

## ワークフロー

```
┌─────────────────────────────────────────────────────────────┐
│                    TDD Orchestration                        │
├─────────────────────────────────────────────────────────────┤
│  1. 分析フェーズ                                             │
│     ├── 対象コード/要件の理解                                │
│     └── 依存関係の特定                                       │
│                                                             │
│  2. テスト設計フェーズ (Opus)                                │
│     ├── テストケース設計                                     │
│     ├── 境界値・エッジケースの洗い出し                        │
│     └── テスト構造の決定                                     │
│                                                             │
│  3. 並列実行フェーズ                                         │
│     ├── [Agent A] テスト実装 (Sonnet)                        │
│     └── [Agent B] 既存テスト実行・確認 (Haiku)               │
│                                                             │
│  4. Red フェーズ                                             │
│     └── テスト実行 → 失敗を確認                              │
│                                                             │
│  5. Green フェーズ (Sonnet)                                  │
│     └── テストを通す最小限のコードを実装                      │
│                                                             │
│  6. Refactor フェーズ                                        │
│     └── コード品質の改善（テストは常に緑を維持）              │
│                                                             │
│  7. 完了報告                                                 │
│     └── テスト結果サマリー + カバレッジ                       │
└─────────────────────────────────────────────────────────────┘
```

## サブエージェント定義

### 1. テスト設計エージェント (test-designer)

**役割**: 何をテストすべきかを分析し、網羅的なテストケースを設計
**モデル**: opus（高品質な設計が必要なため）

```markdown
# テスト設計タスク

## 入力
- 対象ファイル/機能の説明
- 既存のコード（あれば）
- 関連するテストファイル（あれば）

## 出力フォーマット
以下のJSON形式でテストケースを設計してください：

{
  "testFile": "path/to/file.test.ts",
  "describes": [
    {
      "name": "関数名またはコンポーネント名",
      "testCases": [
        {
          "name": "テストケース名",
          "category": "normal|boundary|edge|error",
          "input": "入力の説明",
          "expected": "期待する出力",
          "priority": "high|medium|low"
        }
      ]
    }
  ]
}

## 設計観点
1. **正常系**: 典型的なユースケース
2. **境界値**: 0, 1, 最大値, 最小値, 空配列, null
3. **エッジケース**: 予期しない入力、特殊文字、Unicode
4. **異常系**: エラーハンドリング、例外
5. **状態変化**: 副作用、非同期処理
```

### 2. テスト実装エージェント (test-implementer)

**役割**: 設計されたテストケースを実際のコードに変換
**モデル**: sonnet

```markdown
# テスト実装タスク

## 入力
- テスト設計（test-designerの出力）
- プロジェクトのテストパターン参照

## 実装ルール
1. プロジェクトのテストフレームワークを使用
2. describe/it 構造を使用
3. AAA パターン（Arrange-Act-Assert）に従う
4. 既存テストのスタイルに合わせる

## 出力
- 完全なテストファイルのコード
- 必要なモック/フィクスチャ
```

### 3. テスト実行エージェント (test-runner)

**役割**: テストを実行し、結果を分析
**モデル**: haiku（高速な実行が必要）

```markdown
# テスト実行タスク

## コマンド
{{TEST_COMMAND}} <テストファイルパス>

## 出力
- 成功/失敗の結果
- 失敗したテストの詳細
- カバレッジ（利用可能な場合）

## 分析
- 失敗の原因を特定
- 修正が必要な箇所を報告
```

### 4. 機能実装エージェント (feature-implementer)

**役割**: 失敗しているテストを通すコードを実装
**モデル**: sonnet

```markdown
# 機能実装タスク

## 入力
- 失敗しているテスト
- テストファイルの内容
- 対象ファイル（既存の場合）

## 実装ルール
1. テストを通す最小限のコードを実装
2. YAGNI原則に従う
3. 型安全性を確保
4. 既存のコードスタイルに合わせる

## 出力
- 実装コード
- 型定義（必要な場合）
```

## 実行手順

### Step 1: 分析 & テスト設計

```typescript
// Task tool で test-designer エージェントを起動
Task({
  subagent_type: "Plan",
  model: "opus",
  prompt: `
    以下の機能のテストを設計してください。

    対象: ${targetDescription}
    既存コード: ${existingCode || "なし（新規実装）"}

    プロジェクトのパターンに従ったテストケースを設計してください。
    出力は JSON 形式でお願いします。
  `
})
```

### Step 2: 並列でテスト実装 & 既存テスト確認

```typescript
// 2つのエージェントを並列実行
Promise.all([
  // テスト実装エージェント
  Task({
    subagent_type: "general-purpose",
    model: "sonnet",
    prompt: `
      以下のテスト設計に基づいてテストコードを実装してください。
      ${testDesign}
    `
  }),

  // 既存テスト確認エージェント
  Task({
    subagent_type: "Bash",
    model: "haiku",
    prompt: `
      既存のテストを実行して、現在の状態を確認してください。
      {{TEST_COMMAND}}
    `
  })
])
```

### Step 3: Red - テストが失敗することを確認

```bash
{{TEST_COMMAND}} <新しいテストファイル>
# 失敗することを確認（まだ実装がないため）
```

### Step 4: Green - テストを通す

```typescript
Task({
  subagent_type: "general-purpose",
  model: "sonnet",
  prompt: `
    以下のテストを通す最小限のコードを実装してください。

    テストファイル: ${testFile}
    失敗しているテスト: ${failingTests}
  `
})
```

### Step 5: テスト再実行 & 確認

```bash
{{TEST_COMMAND}} <テストファイル>
# 全て緑になることを確認
```

### Step 6: Refactor（必要な場合）

テストが通った後、コード品質を改善。テストは常に緑を維持。

### Step 7: 完了報告

```markdown
## TDD 完了レポート

### 実装したテスト
- ファイル: `path/to/feature.test.ts`
- テストケース数: 12
  - 正常系: 5
  - 境界値: 3
  - エッジケース: 2
  - 異常系: 2

### テスト結果
12/12 passed

### 実装したコード
- ファイル: `path/to/feature.ts`
- 行数: 45行

### カバレッジ
- Statements: 95%
- Branches: 90%
- Functions: 100%
- Lines: 95%
```

## オプション

| オプション | 説明 | 例 |
|-----------|------|-----|
| `--design-only` | テスト設計のみ実行 | `/tdd feature.ts --design-only` |
| `--skip-refactor` | リファクタリングをスキップ | `/tdd feature.ts --skip-refactor` |
| `--coverage` | カバレッジレポートを出力 | `/tdd feature.ts --coverage` |

## プロジェクト固有設定

このプロジェクトでは以下の設定を使用：

- **テストフレームワーク**: {{TEST_FRAMEWORK}}
- **テストファイルパターン**: `*.test.{ts,tsx}`
- **テストファイル配置**: 対象ファイルと同じディレクトリ
- **実行コマンド**: `{{TEST_COMMAND}}`

## エラーハンドリング

| 状況 | 対応 |
|------|------|
| テスト設計が不十分 | test-designer を再実行 |
| テストが全て通ってしまう | 要件の確認、テストの見直し |
| Green にならない | 実装の見直し、テストケースの妥当性確認 |
| Refactor でテストが壊れる | 直前の状態に戻してやり直し |

## 注意事項

- TDD は「テストファースト」。既存コードにテストを追加する場合は異なるアプローチが必要
- 過度なテストは避ける。重要なロジックに集中
- モックは最小限に。統合テストも検討
- 非同期処理のテストは適切に await を使用
